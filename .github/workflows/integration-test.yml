name: Integration Tests

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to test'
        required: true
        default: 'test'
        type: choice
        options:
          - test
          - staging
  schedule:
    - cron: '0 2 * * 1'  # Weekly on Monday at 2 AM

env:
  TF_VERSION: '1.6.0'
  AWS_REGION: 'us-east-1'

jobs:
  deploy-test-cluster:
    name: 'Deploy Test Cluster'
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    defaults:
      run:
        working-directory: ./IaC

    outputs:
      cluster_name: ${{ steps.output.outputs.cluster_name }}
      cluster_endpoint: ${{ steps.output.outputs.cluster_endpoint }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-IntegrationTest

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Create Test Variables
        run: |
          cat > terraform.tfvars <<EOF
          cluster_name = "eks-test-${{ github.run_number }}"
          environment = "test"
          vpc_id = "${{ secrets.TEST_VPC_ID }}"
          subnet_ids = ${{ secrets.TEST_SUBNET_IDS }}
          allowed_cidr_blocks = ["10.0.0.0/8"]
          enable_public_access = false
          desired_size = 2
          min_size = 1
          max_size = 3
          instance_types = ["t3.small"]
          EOF

      - name: Terraform Init
        run: terraform init

      - name: Terraform Apply
        id: apply
        run: terraform apply -auto-approve -input=false
        timeout-minutes: 30

      - name: Get Outputs
        id: output
        run: |
          echo "cluster_name=$(terraform output -raw cluster_id)" >> $GITHUB_OUTPUT
          echo "cluster_endpoint=$(terraform output -raw cluster_endpoint)" >> $GITHUB_OUTPUT

      - name: Save Terraform State
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state
          path: IaC/terraform.tfstate
          retention-days: 1

  test-cluster:
    name: 'Test Cluster Functionality'
    runs-on: ubuntu-latest
    needs: deploy-test-cluster
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-ClusterTest

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --name ${{ needs.deploy-test-cluster.outputs.cluster_name }} \
            --region ${{ env.AWS_REGION }}

      - name: Test Cluster Access
        run: |
          echo "Testing cluster access..."
          kubectl cluster-info
          kubectl get nodes
          kubectl get namespaces

      - name: Test Node Health
        run: |
          echo "Checking node health..."
          NODE_COUNT=$(kubectl get nodes --no-headers | wc -l)
          echo "Node count: $NODE_COUNT"
          if [ "$NODE_COUNT" -lt 1 ]; then
            echo "❌ No nodes found"
            exit 1
          fi
          
          READY_NODES=$(kubectl get nodes --no-headers | grep -c " Ready ")
          echo "Ready nodes: $READY_NODES"
          if [ "$READY_NODES" -lt 1 ]; then
            echo "❌ No ready nodes"
            exit 1
          fi
          
          echo "✅ All nodes are ready"

      - name: Test Pod Deployment
        run: |
          echo "Testing pod deployment..."
          kubectl create namespace test-deployment
          
          cat <<EOF | kubectl apply -f -
          apiVersion: v1
          kind: Pod
          metadata:
            name: test-pod
            namespace: test-deployment
          spec:
            containers:
            - name: nginx
              image: nginx:latest
              ports:
              - containerPort: 80
          EOF
          
          echo "Waiting for pod to be ready..."
          kubectl wait --for=condition=ready pod/test-pod -n test-deployment --timeout=120s
          
          echo "✅ Pod deployment successful"

      - name: Test Secrets Encryption
        run: |
          echo "Testing secrets encryption..."
          kubectl create secret generic test-secret \
            --from-literal=password=supersecret \
            -n test-deployment
          
          kubectl get secret test-secret -n test-deployment -o yaml
          
          echo "✅ Secrets encryption working"

      - name: Test Network Policies
        run: |
          echo "Testing network connectivity..."
          kubectl exec test-pod -n test-deployment -- curl -s http://www.google.com > /dev/null
          echo "✅ Network connectivity working"

      - name: Test RBAC
        run: |
          echo "Testing RBAC..."
          kubectl auth can-i create pods --as=system:serviceaccount:default:default
          echo "✅ RBAC configured"

      - name: Cleanup Test Resources
        if: always()
        run: |
          kubectl delete namespace test-deployment --ignore-not-found=true

  security-validation:
    name: 'Security Validation'
    runs-on: ubuntu-latest
    needs: deploy-test-cluster
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-SecurityValidation

      - name: Validate Encryption
        run: |
          echo "Validating encryption settings..."
          CLUSTER_NAME="${{ needs.deploy-test-cluster.outputs.cluster_name }}"
          
          # Check secrets encryption
          ENCRYPTION=$(aws eks describe-cluster --name $CLUSTER_NAME --query 'cluster.encryptionConfig[0].resources[0]' --output text)
          if [ "$ENCRYPTION" != "secrets" ]; then
            echo "❌ Secrets encryption not enabled"
            exit 1
          fi
          echo "✅ Secrets encryption enabled"

      - name: Validate Logging
        run: |
          echo "Validating logging configuration..."
          CLUSTER_NAME="${{ needs.deploy-test-cluster.outputs.cluster_name }}"
          
          LOGS=$(aws eks describe-cluster --name $CLUSTER_NAME --query 'cluster.logging.clusterLogging[0].enabled' --output text)
          if [ "$LOGS" != "True" ]; then
            echo "❌ Cluster logging not enabled"
            exit 1
          fi
          echo "✅ Cluster logging enabled"

      - name: Validate Private Endpoint
        run: |
          echo "Validating endpoint configuration..."
          CLUSTER_NAME="${{ needs.deploy-test-cluster.outputs.cluster_name }}"
          
          PRIVATE=$(aws eks describe-cluster --name $CLUSTER_NAME --query 'cluster.resourcesVpcConfig.endpointPrivateAccess' --output text)
          if [ "$PRIVATE" != "True" ]; then
            echo "❌ Private endpoint not enabled"
            exit 1
          fi
          echo "✅ Private endpoint enabled"

      - name: Validate Node Encryption
        run: |
          echo "Validating node volume encryption..."
          CLUSTER_NAME="${{ needs.deploy-test-cluster.outputs.cluster_name }}"
          
          # Get node group
          NODE_GROUP=$(aws eks list-nodegroups --cluster-name $CLUSTER_NAME --query 'nodegroups[0]' --output text)
          
          # Check launch template
          LT_ID=$(aws eks describe-nodegroup --cluster-name $CLUSTER_NAME --nodegroup-name $NODE_GROUP --query 'nodegroup.launchTemplate.id' --output text)
          
          ENCRYPTED=$(aws ec2 describe-launch-template-versions --launch-template-id $LT_ID --query 'LaunchTemplateVersions[0].LaunchTemplateData.BlockDeviceMappings[0].Ebs.Encrypted' --output text)
          
          if [ "$ENCRYPTED" != "True" ]; then
            echo "❌ Node volumes not encrypted"
            exit 1
          fi
          echo "✅ Node volumes encrypted"

  cleanup:
    name: 'Cleanup Test Resources'
    runs-on: ubuntu-latest
    needs: [deploy-test-cluster, test-cluster, security-validation]
    if: always()
    permissions:
      id-token: write
      contents: read

    defaults:
      run:
        working-directory: ./IaC

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Cleanup

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Download Terraform State
        uses: actions/download-artifact@v4
        with:
          name: terraform-state
          path: IaC/

      - name: Terraform Init
        run: terraform init

      - name: Terraform Destroy
        run: terraform destroy -auto-approve -input=false
        timeout-minutes: 30

      - name: Verify Cleanup
        run: |
          echo "Verifying all resources are cleaned up..."
          CLUSTER_NAME="eks-test-${{ github.run_number }}"
          
          if aws eks describe-cluster --name $CLUSTER_NAME 2>/dev/null; then
            echo "⚠️ Cluster still exists"
          else
            echo "✅ Cluster successfully deleted"
          fi
